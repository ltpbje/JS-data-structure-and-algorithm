<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        function mergeSort(array) {
            // 如果数组的长度大于1，说明数组至少有两个元素，需要进行排序
            if (array.length > 1) {
                // 获取数组的长度
                const { length } = array;
                // 计算数组的中间位置，用于将数组分成左右两部分
                const middle = Math.floor(length / 2);
                // 递归地对数组的左半部分进行归并排序
                const left = mergeSort(array.slice(0, middle));
                // 递归地对数组的右半部分进行归并排序
                const right = mergeSort(array.slice(middle, length));
                // 将排好序的左半部分和右半部分合并，并赋值给原数组
                array = merge(left, right);
            }
            console.log(array);

            // 返回排好序的数组
            return array;
        }


        function merge(left, right) {
            // 初始化左子数组的索引为0
            let i = 0;
            // 初始化右子数组的索引为0
            let j = 0;
            // 创建一个空数组，用于存储合并后的结果
            const result = [];
            // 当左子数组和右子数组都还有未处理的元素时
            while (i < left.length && j < right.length) {
                // 如果左子数组当前元素小于右子数组当前元素
                result.push(
                    left[i] < right[j] ? left[i++] : right[j++]
                );
                // 先将较小的元素添加到结果数组中，然后相应子数组的索引后移一位
                console.log(result);
                // 打印当前合并的中间结果，方便查看排序过程
            }
            // 如果左子数组还有剩余元素，将其全部添加到结果数组中
            return result.concat(i < left.length ? left.slice(i) : right.slice(j));
        }
        mergeSort([2, 3, 1, 9, 4, 5, 6]);
    </script>
</body>

</html>